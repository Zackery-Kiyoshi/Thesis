package util

class DataFormula {
  
}

/*

/* Generated by Together */
package edu.swri.swiftvis;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.io.Serializable;
import java.util.HashSet;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;

import edu.swri.swiftvis.scheme.SVSchemeUtil;
import edu.swri.swiftvis.scheme.SchemeConsole;
import edu.swri.swiftvis.scheme.SchemeElement;
import edu.swri.swiftvis.scheme.SchemeValue;

/**
* This class is intended to allow users to type in formulas that can be applied
* to the inputs of a given data sink.  The formulas can use standard mathematical
* functions in them in normal infix notation with parentheses.  It also allows
* you to specify data from one of the inputs.  Typically the functions will be
* working on a particular DataElement though it is possible to refer to earlier
* or later elements as well.  The format for referring to data elements is
* d[#].p[#] for an integer property or d[#].v[#] for a value.  The # in the
* d subscript is which source for that sink to use.  The # in the p or v
* subscript is which property of value.
*
* To refer to values of earlier of later elements you can use a format like
* d[#].v[offset][#].  Here the offset is how many data elements forward or
* backward to look.  The shorter form above is equivalent to d[#].v[0][#].
*
* Because many situations will involve only one data source, you can also use
* a shorter notation where the d[#]. is dropped off.  In this case the [0]
* source is assumed.
* 
* These formulas support the operators +, -, *, /, %, and ** as well as the ternary
* operator ?: for doing conditionals (See BooleanFormula for the format of the
* conditionals).  In addition, They can also include the
* functions sin, cos, tan, sqrt, exp, log, abs, rand, floor, and round.
* 
* The class also has built into it the ability to include values or parameters
* selected from a "group" of adjacent elements.  A group is defined by a formula
* and any sequential elements with the same value of that formula are part of the
* group.  Group information is specified in braces before the rest of the formula.
* The format is {group formula, boolean selector 1, boolean selector 2, ...}.
* In the formula, the selected indices are specified with primes (').  The following
* formula would return the difference between the current semimajor axis and that of
* the second planet for a bin.dat input {v[0],p[0]=-2} v[1]-v'[1].  Note that the grouping
* is done by time so that we compare bodies during the same timestep which is all that
* makes sense. 
*
* This class parses the formula out to an expression tree to enable
* quick evalutation.
**/
public class DataFormula implements Serializable {
    public static void main(String[] args) {
        String[] equs={"5","5+2","5*(3+2)","2**2","2<4?1:0","2>4?1:0","2+2<4?1:0"};
        double[] results={5,7,25,4,1,0,0};
        for(int i=0; i<equs.length; ++i) {
            if(new DataFormula(equs[i]).valueOf(null,0, 0)!=results[i]) System.out.println("Failed on "+equs[i]);
            System.out.print(".");
        }
        DataFormula df=new DataFormula("3+v[0]*sin(6/7)");
        System.out.println(df.root);
        System.out.println(df.getFormula());
        df.rebuildFormulaString();
        System.out.println(df.getFormula());
        new DataFormula("(3.0+(v[0]*sin((6.0/7.0))))");
        df=new DataFormula("0*v[0]");
        System.out.println(df.root);
        df=new DataFormula("0+v[0]");
        System.out.println(df.root);
        df=new DataFormula("v[0]-0");
        System.out.println(df.root);
        df=new DataFormula("v[0]/1");
        System.out.println(df.root);
    }
    
    private DataFormula() {
    }

    public DataFormula(String equation) {
        parse(equation);
    }
    
    public DataFormula(DataFormula c) {
        parse(c.equ);
    }
    
    @Override
    public boolean equals(Object o) {
    	if(!(o instanceof DataFormula)) return false;
    	DataFormula df=((DataFormula)o);
    	return ((groupInfo==null && df.groupInfo==null) || (groupInfo!=null && groupInfo.equals(df.groupInfo)))
    		&& df.root.equals(root);
    }

    /**
     * Get the string formula.
     * @return The formula as a string.
     */
    public String getFormula() {
        return equ;
    }
    
    /**
     * Set the formula for this object and parse it to the tree.
     * @param equation The new formula as a string.
     */
    public void setFormula(String equation) {
        parse(equation);
        if(inputField!=null) {
            inputField.setText(equation);
        }
    }
    
    /**
     * Returns a list of the variables that are used in this formula.
     * @return A list of variables in this formula.
     */
    public Set<String> listVariables() {
        Set<String> ret=new HashSet<String>();
        root.collectVars(ret);
        return ret;
    }
    
    public boolean[] getUsedInputs() {
        boolean[] ret=new boolean[100];
        root.inputsUsed(ret);
        return ret;
    }


    /**
	 * Returns the value of the given expression using the provided DataSink,
	 * primary element.  Special elements are calculated using group settings.
     * @param stream The stream to use.
	 * @throws ArithmeticException This means that it tried an undefinied operation.
	 * @throws NoSuchElementException A provided subscript was out of bounds.
	 */
	public double valueOf(DataSink sink,int stream, int elem) {
		return valueOf(sink,stream,elem, null, null);
	}

    /**
	 * Returns the value of the given expression using the provided DataSink,
	 * primary element, and special element.  The special element array can be
	 * null if none has been precalculated.
     * @param stream The stream to use.
	 * @throws ArithmeticException This means that it tried an undefinied operation.
	 * @throws NoSuchElementException A provided subscript was out of bounds.
	 */
	public double valueOf(DataSink sink,int stream,int elem, int[] specialElem) {
		return valueOf(sink,stream,elem, specialElem, null);
	}

    /**
     * Returns the value of the given expression using the provided DataSink,
     * primary element, special elements, and variable hash.  The special element
     * array can be null if none has been precalculated.  The variable hash can also
     * be null if the expression does not include any variables.
     * @param stream The stream to use.
     * @throws ArithmeticException This means that it tried an undefinied operation.
     * @throws NoSuchElementException A provided subscript was out of bounds.
     */
    public double valueOf(DataSink sink,int stream,int elem,int[] specialElem, Map<String,Double> varHash) {
        if(groupInfo!=null) {
            specialElem=groupInfo.getSpecialArray(sink,stream,elem, specialElem);
        }
        return root.eval(sink,stream,elem,specialElem, varHash);
    }

    /**
     * Returns the smallest and largest element numbers that are safe to use
     * with this formula.  This only checks the various data sources used and
     * the offsets in them.
     * @param stream The stream to check for.
     */
    public int[] getSafeElementRange(DataSink sink, int stream) {
        clearGroupSelection();
        return root.getSafeElementRange(sink,stream);
    }
    
    /**
     * Merges two ranges into the first range.
     * @param r1 This is the first range [min,max] and also where the merged range will go.
     * @param r2 This is the second range [min,max].
     */
    public static void mergeSafeElementRanges(int[] r1,int[] r2) {
        if(r2[0]>r1[0]) r1[0]=r2[0];
        if(r2[1]<r1[1]) r1[1]=r2[1];
    }
    
    public static void checkRangeSafety(int[] minMax,DataSink sink) {
        if(minMax[1]==Integer.MAX_VALUE) {
            int maxElems=0;
            for(int i=0; i<sink.getNumSources(); ++i) {
                for(int j=0; j<sink.getSource(i).getNumStreams(); ++j) {
                    if(maxElems<sink.getSource(i).getNumElements(j)) maxElems=sink.getSource(i).getNumElements(j);
                }
            }
            minMax[1]=maxElems;
        }
        if(minMax[0]<0) minMax[0]=0;
    }

    /**
     * This method returns a text field that can be put into a GUI to edit this formula.
     * If the formula hasn't created one yet, it will create it.  This field has listeners
     * attached to it that will update the formula on action or focus loss.  The provided
     * DataFormulaListener will be notified when the formula is altered.  It can be null.
     */
    public JTextField getTextField(Listener dfl) {
        if(inputField==null) {
            listener=dfl;
            inputField=new JTextField(equ);
            inputField.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) { formulaChanged(); }
        	} );
            inputField.addFocusListener(new FocusAdapter() {
                @Override
                public void focusLost(FocusEvent e) {
                    if(e.isTemporary() || e.getOppositeComponent()==null) return;
                    formulaChanged();
                }
        	} );
        }
        return inputField;
    }
    
    public JPanel getLabeledTextField(String text,Listener dfl) {
        JPanel ret=new JPanel(new BorderLayout());
        ret.add(new JLabel(text),BorderLayout.WEST);
        ret.add(getTextField(dfl),BorderLayout.CENTER);
        return ret;
    }
    
    /**
     * This method will return a DataFormula object that can be used in place of the
     * current one for parallel processing.  Basically, it will share references to equ and
     * root, but have a copy of the groupInfo since that is mutated by evaluation.
     */
    public DataFormula getParallelCopy() {
        if(groupInfo==null) return this;
        DataFormula ret=new DataFormula();
        ret.equ=equ;
        ret.root=root;
        ret.groupInfo=new GroupInformation(groupInfo);
        return ret;
    }
    
    public void clearGroupSelection() {
        if(groupInfo!=null) {
            groupInfo.reset();
        }
    }
    
    public void simplify() {
        root=root.simplify();
    }
    
    public void rebuildFormulaString() {
        equ=root.toString();
        if(inputField!=null) inputField.setText(equ);
    }
    
    public void mapSources(Map<Integer,Integer> newSources) {
        root.mapSources(newSources);
        rebuildFormulaString();
    }
    
    @Override
    public String toString() {
        return equ;
    }
    
    public interface Listener {
        void formulaChanged();
    }
    
    private static final int TERT_LEVEL=5;
    private static final int PLUS_LEVEL=4;
    private static final int MULT_LEVEL=3;
    private static final int EXP_LEVEL=2;
    private static final int NO_LEVEL=0;
    
    private EquNode parseToTree(String e) {
        int opLoc=-1;
        int colonLoc=-1;
        int parensCount=0;
        int bracketCount=0;
        int ternaryCount=0;
        int level=NO_LEVEL;

        e=e.trim();
        for(int i=e.length()-1; i>=0; i--) {
            if(e.charAt(i)=='(') parensCount++;
            else if(e.charAt(i)==')') parensCount--;
			else if(e.charAt(i)=='[') bracketCount++;
			else if(e.charAt(i)==']') bracketCount--;
			else if(e.charAt(i)==':') {
                if(parensCount==0 && bracketCount==0 && ternaryCount==0) {
                    colonLoc=i;                    
                }
                ternaryCount++;
            }
            else if(e.charAt(i)=='?') {
                ternaryCount--;
                if(level<TERT_LEVEL && parensCount==0 && bracketCount==0 && ternaryCount==0 && (e.charAt(i)=='?')) {
                    opLoc=i;
                    level=TERT_LEVEL;
                }
            } else if(level<PLUS_LEVEL && parensCount==0 && bracketCount==0 && ternaryCount==0 && (e.charAt(i)=='+' || e.charAt(i)=='-')) {
                boolean validOp=true;
                if(e.charAt(i)=='-') {
                    // no space between * /
                    String negPred="eE(+-* /";
                    if(i!=0 && negPred.indexOf(e.charAt(i-1))>-1) validOp=false;
                }
                if(validOp) {
                    opLoc=i;
                    level=PLUS_LEVEL;
                }
            } else if(level<MULT_LEVEL && parensCount==0 && bracketCount==0 && ternaryCount==0 && (e.charAt(i)=='*' || e.charAt(i)=='/' || e.charAt(i)=='%')) {
                if(e.charAt(i)!='*' || (e.charAt(i-1)!='*' && e.charAt(i+1)!='*')) {
                    level=MULT_LEVEL;
                    opLoc=i;
                }
            }
        }
		if(level<=EXP_LEVEL) {
		    if(parensCount!=0 || bracketCount!=0 || ternaryCount!=0) {
		        throw new IllegalArgumentException("Unbalanced : "+e);
		    }
	        for(int i=0; i<e.length()-1; i++) {
	            if(e.charAt(i)=='(') parensCount++;
	            else if(e.charAt(i)==')') parensCount--;
				else if(e.charAt(i)=='[') bracketCount++;
				else if(e.charAt(i)==']') bracketCount--;
				else if(e.charAt(i)==':') ternaryCount++;
				else if(e.charAt(i)=='?') ternaryCount--;
	            else if(level<EXP_LEVEL && parensCount==0 && bracketCount==0 && ternaryCount==0 && e.charAt(i)=='*' && e.charAt(i+1)=='*') {
	                opLoc=i;
	                level=EXP_LEVEL;
	            }
	        }
		}
		if(opLoc<0) {
            if(e.charAt(0)=='(') {
                return parseToTree(e.substring(1,e.length()-1));
            } else if(e.startsWith("scm(")) {
                return new SchemeNode(e.substring(3,e.length()));
            } else if(e.startsWith("sin(")) {
                return new SinNode(parseToTree(e.substring(4,e.length()-1)));
            } else if(e.startsWith("cos(")) {
                return  new CosNode(parseToTree(e.substring(4,e.length()-1)));
            } else if(e.startsWith("tan(")) {
                return new TanNode(parseToTree(e.substring(4,e.length()-1)));
            } else if(e.startsWith("sqrt(")) {
                return new SqrtNode(parseToTree(e.substring(5,e.length()-1)));
            } else if(e.startsWith("cbrt(")) {
                return new CbrtNode(parseToTree(e.substring(5,e.length()-1)));
            } else if(e.startsWith("exp(")) {
                return new ExpNode(parseToTree(e.substring(4,e.length()-1)));
            } else if(e.startsWith("log(")) {
                return new LogNode(parseToTree(e.substring(4,e.length()-1)));
            } else if(e.startsWith("log10(")) {
                return new Log10Node(parseToTree(e.substring(6,e.length()-1)));
            } else if(e.startsWith("log2(")) {
                return new Log2Node(parseToTree(e.substring(5,e.length()-1)));
            } else if(e.startsWith("cosh(")) {
                return  new CoshNode(parseToTree(e.substring(5,e.length()-1)));
            } else if(e.startsWith("sinh(")) {
                return  new SinhNode(parseToTree(e.substring(5,e.length()-1)));
            } else if(e.startsWith("abs(")) {
                return new AbsNode(parseToTree(e.substring(4,e.length()-1)));
            } else if(e.startsWith("rand(")) {
                return new RandNode(parseToTree(e.substring(5,e.length()-1)));
            } else if(e.startsWith("floor(")) {
                return new FloorNode(parseToTree(e.substring(6,e.length()-1)));
            } else if(e.startsWith("round(")) {
                return new RoundNode(parseToTree(e.substring(6,e.length()-1)));
            } else if(e.startsWith("atan2(")) {
                String[] parts=breakOnComma(e.substring(6,e.length()-1));
                return new Atan2Node(parseToTree(parts[0]),parseToTree(parts[1]));
            } else if(e.startsWith("hypot(")) {
                String[] parts=breakOnComma(e.substring(6,e.length()-1));
                return new HypotNode(parseToTree(parts[0]),parseToTree(parts[1]));
            } else if(e.startsWith("min(")) {
                String[] parts=breakOnComma(e.substring(4,e.length()-1));
                return new MinNode(parseToTree(parts[0]),parseToTree(parts[1]));
            } else if(e.startsWith("max(")) {
                String[] parts=breakOnComma(e.substring(4,e.length()-1));
                return new MaxNode(parseToTree(parts[0]),parseToTree(parts[1]));
            } else if(e.startsWith("asin(")) {
                return new AsinNode(parseToTree(e.substring(5,e.length()-1)));
            } else if(e.startsWith("acos(")) {
                return  new AcosNode(parseToTree(e.substring(5,e.length()-1)));
            } else if(e.startsWith("sign(")) {
                return  new SignNode(parseToTree(e.substring(5,e.length()-1)));
            } else if(e.startsWith("PI")) {
                return new NumberNode(Math.PI);
            } else if(e.startsWith("index")) {
                return new IndexNode();
            } else if(e.startsWith("numElements")) {
                return new NumElementsNode((e.length()>11)?e.substring(11):null);
            } else if(e.startsWith("numValues")) {
                return new NumValuesNode((e.length()>9)?e.substring(9):null);
            } else if(e.startsWith("numParams")) {
                return new NumParamsNode((e.length()>9)?e.substring(9):null);
            } else {
                try {
                    return new NumberNode(Double.parseDouble(e));
                } catch(NumberFormatException ex) {
                    Matcher pvMatcher=PVPattern.matcher(e);
                    if(pvMatcher.matches()) {
                        int input=0;
                        if(pvMatcher.group(2)!=null) {
                            input=Integer.parseInt(pvMatcher.group(2));
                        }
                        int stream=-1;
                        if(pvMatcher.group(4)!=null) {
                            stream=Integer.parseInt(pvMatcher.group(4));
                        }
                        int offset=0;
                        if(pvMatcher.group(8)!=null) {
                            offset=Integer.parseInt(pvMatcher.group(8));
                        }
                        int index=Integer.parseInt(pvMatcher.group(9));
                        if(pvMatcher.group(6).length()==0) {
                            if(pvMatcher.group(5).equals("p")) {
                                return new ParamNode(input,stream,offset,index);
                            } else {
                                return new ValueNode(input,stream,offset,index);
                            }
                        } else {
                            int primes=pvMatcher.group(6).length()-1;
                            if(pvMatcher.group(5).equals("p")) {
                                return new SpecialParamNode(input,stream,offset,index,primes);
                            } else {
                                return new SpecialValueNode(input,stream,offset,index,primes);
                            }                            
                        }
                    }
                    Matcher cpvMatcher=constPVPattern.matcher(e);
                    if(cpvMatcher.matches()) {
                        int input=Integer.parseInt(cpvMatcher.group(1));
                        int stream=-1;
                        if(cpvMatcher.group(3)!=null) {
                            stream=Integer.parseInt(cpvMatcher.group(3));
                        }
                        int offset=0;
                        if(cpvMatcher.group(6)!=null) {
                            offset=Integer.parseInt(cpvMatcher.group(6));
                        }
                        int index=Integer.parseInt(cpvMatcher.group(7));                        
                        if(cpvMatcher.group(4).equals("p")) {
                            return new ConstParamNode(input,stream,offset,index);
                        } else {
                            return new ConstValueNode(input,stream,offset,index);
                        }
                    }
                    Matcher matcher=variablePattern.matcher(e);
                    if(matcher.matches()) {
                        return new VariableNode(e);
                    } else {
                        Thread.dumpStack();
                        throw new RuntimeException("Couldn't properly parse the string '"+e+"'.");
                    }
                }
            }
        } else {
            switch(e.charAt(opLoc)) {
            case '+':
                return new PlusNode(parseToTree(e.substring(0,opLoc)),parseToTree(e.substring(opLoc+1)));
            case '-':
            	if(opLoc==0) {
            		try {
						return new NumberNode(Double.parseDouble(e));
            		} catch(NumberFormatException ex) {
						return new MinusNode(new NumberNode(0.0),parseToTree(e.substring(opLoc+1)));
            		}
            	} else {
					return new MinusNode(parseToTree(e.substring(0,opLoc)),parseToTree(e.substring(opLoc+1)));
            	}
            case '*':
                if(level==EXP_LEVEL) {
                    return new PowNode(parseToTree(e.substring(0,opLoc)),parseToTree(e.substring(opLoc+2)));
                }
                return new MultNode(parseToTree(e.substring(0,opLoc)),parseToTree(e.substring(opLoc+1)));
            case '/':
                return new DivNode(parseToTree(e.substring(0,opLoc)),parseToTree(e.substring(opLoc+1)));
			case '%':
				return new ModNode(parseToTree(e.substring(0,opLoc)),parseToTree(e.substring(opLoc+1)));
			case '?':
			    return new TernaryNode(new BooleanFormula(e.substring(0,opLoc)),parseToTree(e.substring(opLoc+1,colonLoc)),parseToTree(e.substring(colonLoc+1)));
            }
        }
        return null;
    }

    private void parse(String equation) {
        equ = equation.trim();
        if (equ.charAt(0) == '{') {
            int i = 1;
            int braceCount = 1;
            while (braceCount > 0) {
                switch (equ.charAt(i)) {
                    case '{' :
                        braceCount++;
                        break;
                    case '}' :
                        braceCount--;
                        break;
                }
                ++i;
            }
            groupInfo = new GroupInformation(equ.substring(0, i));
            equ = equ.substring(i);
        }
        root = parseToTree(equ).simplify();
        equ = equation;
    }

    private String[] breakOnComma(String s) {
        int parensCount=0;
        for(int i=0; i<s.length(); ++i) {
            if(s.charAt(i)=='(') parensCount++;
            else if(s.charAt(i)==')') parensCount--;
            else if(s.charAt(i)==',' && parensCount==0) {
                String[] ret=new String[2];
                ret[0]=s.substring(0,i);
                ret[1]=s.substring(i+1);
                return ret;
            }
        }
        throw new RuntimeException("Error in formula! Expecting comma in: "+s);
    }
    
    private void formulaChanged() {
        if(inputField.getText().equals(equ)) return;
        try {
            parse(inputField.getText());
        } catch(Exception e) {
            JOptionPane.showMessageDialog(inputField,"There was an exception parsing the formula.\nSpecific Error: "+e.getMessage());
            inputField.requestFocus();
        }
        if(listener!=null) listener.formulaChanged();
    }

    private String equ;
    private EquNode root;
    private GroupInformation groupInfo;
    
    private transient JTextField inputField;
    private transient Listener listener;

    private static final long serialVersionUID=783923672578l;
    private static Pattern PVPattern=Pattern.compile("(d\\[(\\d+)\\](\\[(\\d+)\\])?\\.)?([vp])('*)(\\[(-?\\d+)\\])?\\[(\\d+)\\]");
    private static Pattern variablePattern=Pattern.compile("[a-zA-Z]\\w*");
    private static Pattern constPVPattern=Pattern.compile("c\\[(\\d+)\\](\\[(\\d+)\\])?\\.([vp])(\\[(-?\\d+)\\])?\\[(\\d+)\\]");

    private interface EquNode extends Serializable {
		double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash);
        int[] getSafeElementRange(DataSink sink, int stream);
        void collectVars(Set<String> vars);
        void inputsUsed(boolean[] inputs);
        boolean isNumber();
        EquNode simplify();
        void mapSources(Map<Integer,Integer> ns);
    }
    
    private static abstract class BinaryOpt implements EquNode {
        public BinaryOpt(EquNode l,EquNode r) { left=l; right=r; }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] l=left.getSafeElementRange(sink,stream);
            int[] r=right.getSafeElementRange(sink,stream);
            l[0]=Math.max(l[0],r[0]);
            l[1]=Math.min(l[1],r[1]);
            return l;
        }
        @Override
        public boolean equals(Object o) {
            if(!(this.getClass().isInstance(o))) return false;
            BinaryOpt node=(BinaryOpt)o;
            return (left.equals(node.left) && right.equals(node.right)) ||
                (left.equals(node.right) && right.equals(node.left));
        }
        @Override
        public void collectVars(Set<String> vars) { left.collectVars(vars); right.collectVars(vars); }
        @Override
        public void inputsUsed(boolean[] inputs) {left.inputsUsed(inputs); right.inputsUsed(inputs); }
        @Override
        public boolean isNumber() { return left.isNumber() && right.isNumber(); }
        @Override
        public EquNode simplify() {
            left=left.simplify();
            right=right.simplify();
            if(isNumber()) {
                return new NumberNode(eval(null,0,0,null,null));
            } else return this;
        }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            left.mapSources(ns);
            right.mapSources(ns);
        }
        protected EquNode left;
        protected EquNode right;
        private static final long serialVersionUID = -3282427993013262650L;
    }
    
    private static abstract class MonaryOpt implements EquNode {
        public MonaryOpt(EquNode a) { arg=a; }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            return arg.getSafeElementRange(sink,stream);
        }
        @Override
        public boolean equals(Object o) {
            if(!(this.getClass().isInstance(o))) return false;
            return arg.equals(((MonaryOpt)o).arg);
        }
        @Override
        public void collectVars(Set<String> vars) { arg.collectVars(vars); }
        @Override
        public void inputsUsed(boolean[] inputs) { arg.inputsUsed(inputs); }
        @Override
        public boolean isNumber() { return arg.isNumber(); }
        @Override
        public EquNode simplify() {
            arg=arg.simplify();
            if(isNumber()) {
                return new NumberNode(eval(null,0,0,null,null));
            } else return this;
        }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            arg.mapSources(ns);
        }
        protected EquNode arg;        
        private static final long serialVersionUID = 5379463453636389092L;
    }

    private static class PlusNode extends BinaryOpt {
        public PlusNode(EquNode l,EquNode r) { super(l,r); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return left.eval(sink,stream,elem,se, varHash)+right.eval(sink,stream,elem,se, varHash); }
		@Override
        public String toString() { return "("+left+"+"+right+")"; }
		@Override
        public EquNode simplify() {
		    EquNode ret=super.simplify();
		    if(ret.isNumber()) return ret;
		    if(left.isNumber() && left.eval(null,0,0,null,null)==0) return right;
		    else if(right.isNumber() && right.eval(null,0,0,null,null)==0) return left;
		    return ret;
		}
        private static final long serialVersionUID=783923672235l;
    }

    private static class MinusNode extends BinaryOpt {
        public MinusNode(EquNode l,EquNode r) { super(l,r); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return left.eval(sink,stream,elem,se, varHash)-right.eval(sink,stream,elem,se, varHash); }
        @Override
        public String toString() { return "("+left+"-"+right+")"; }
        @Override
        public EquNode simplify() {
            EquNode ret=super.simplify();
            if(ret.isNumber()) return ret;
            if(right.isNumber() && right.eval(null,0,0,null,null)==0) return left;
            return ret;
        }
        private static final long serialVersionUID=783913462578l;
    }

    private static class MultNode extends BinaryOpt {
        public MultNode(EquNode l,EquNode r) { super(l,r); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return left.eval(sink,stream,elem,se, varHash)*right.eval(sink,stream,elem,se, varHash); }
        @Override
        public String toString() { return "("+left+"*"+right+")"; }
        @Override
        public EquNode simplify() {
            EquNode ret=super.simplify();
            if(ret.isNumber()) return ret;
            if(left.isNumber()) {
                double v=left.eval(null,0,0,null,null);
                if(v==1) return right;
                if(v==0) return new NumberNode(0);
            } else if(right.isNumber()) {
                double v=right.eval(null,0,0,null,null);
                if(v==1) return left;
                if(v==0) return new NumberNode(0);
            }
            return ret;
        }
        private static final long serialVersionUID=358723462487l;
    }

    private static class DivNode extends BinaryOpt {
        public DivNode(EquNode l,EquNode r) { super(l,r); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return left.eval(sink,stream,elem,se, varHash)/right.eval(sink,stream,elem,se, varHash); }
        @Override
        public String toString() { return "("+left+"/"+right+")"; }
        @Override
        public EquNode simplify() {
            EquNode ret=super.simplify();
            if(ret.isNumber()) return ret;
            if(left.isNumber()) {
                double v=left.eval(null,0,0,null,null);
                if(v==0) return new NumberNode(0);
            } else if(right.isNumber()) {
                double v=right.eval(null,0,0,null,null);
                if(v==1) return left;
            }
            return ret;
        }
        private static final long serialVersionUID=579912346872l;
    }

    private static class ModNode extends BinaryOpt {
		public ModNode(EquNode l,EquNode r) { super(l,r); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return left.eval(sink,stream,elem,se, varHash)%right.eval(sink,stream,elem,se, varHash); }
        @Override
        public String toString() { return "("+left+"%"+right+")"; }
        private static final long serialVersionUID=148923672578l;
	}

    private static class PowNode extends BinaryOpt {
        public PowNode(EquNode l,EquNode r) { super(l,r); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.pow(left.eval(sink,stream,elem,se, varHash),right.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "("+left+"**"+right+")"; }
        private static final long serialVersionUID=345698714089l;
    }

    private static class TernaryNode implements EquNode {
		public TernaryNode(BooleanFormula bf,EquNode l,EquNode r) { cond=bf; left=l; right=r; }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) {
		    if(cond.valueOf(sink,0,elem,se, varHash)) {
			    return left.eval(sink,stream,elem,se, varHash);
		    } else {
			    return right.eval(sink,stream,elem,se, varHash);
		    }
		}
		@Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
		    int[] b=cond.getSafeElementRange(sink, 0);
			int[] l=left.getSafeElementRange(sink,stream);
			int[] r=right.getSafeElementRange(sink,stream);
			l[0]=Math.max(b[0],Math.max(l[0],r[0]));
			l[1]=Math.min(b[1],Math.min(l[1],r[1]));
			return l;
		}
		@Override
        public boolean equals(Object o) {
			if(!(o instanceof TernaryNode)) return false;
			TernaryNode node=(TernaryNode)o;
			return cond.equals(node.cond) && left.equals(node.left) && right.equals(node.right);
		}
        @Override
        public void collectVars(Set<String> vars) { left.collectVars(vars); right.collectVars(vars); }
        @Override
        public void inputsUsed(boolean[] inputs) {left.inputsUsed(inputs); right.inputsUsed(inputs); }
        @Override
        public boolean isNumber() { return false; }
        @Override
        public EquNode simplify() {
            return this;
        }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            cond.mapSources(ns);
            left.mapSources(ns);
            right.mapSources(ns);
        }
        @Override
        public String toString() { return "(("+cond+")?("+left+"):("+right+"))"; }

        private BooleanFormula cond;
        private EquNode left;
        private EquNode right;
        private static final long serialVersionUID=356089714l;
    }
    
	private static class ValueNode implements EquNode {
		public ValueNode(int src,int strm,int off,int i) { source=src; stream=strm; offset=off; index=i; }
		@Override
        public double eval(DataSink sink,int strm,int elem, int[] se, Map<String, Double> varHash) {
		    if(stream>=0) strm=stream;
			return sink.getSource(source).getElement(elem+offset,strm).getValue(index);
		}
		@Override
        public int[] getSafeElementRange(DataSink sink, int strm) {
            if(stream>=0) strm=stream;
			int[] ret={-offset,sink.getSource(source).getNumElements(strm)-offset};
			return ret;
		}
		@Override
        public boolean equals(Object o) {
			if(!(o instanceof ValueNode)) return false;
			ValueNode node=(ValueNode)o;
			return source==node.source && offset==node.offset && index==node.index;
		}
        @Override
        public void collectVars(Set<String> vars) {}
        @Override
        public void inputsUsed(boolean[] inputs) { inputs[source]=true; }
        @Override
        public boolean isNumber() { return false; }
        @Override
        public EquNode simplify() {
            return this;
        }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            if(ns.containsKey(source)) {
                source=ns.get(source);
            }
        }
        @Override
        public String toString() {
            String first="";
            if(source>0 && stream==-1) first="d["+source+"].";
            else if(source>0 || stream>=0) first="d["+source+"]["+stream+"].";
            String second;
            if(offset!=0) second="v["+offset+"]["+index+"]";
            else second="v["+index+"]";
            return first+second;
        }
		private int source;
		private int stream;
		private int offset;
		private int index;
        private static final long serialVersionUID=29837460987l;
	}
    
	private static class ParamNode implements EquNode {
		public ParamNode(int src,int strm,int off,int i) { source=src; stream=strm; offset=off; index=i; }
		@Override
        public double eval(DataSink sink,int strm,int elem, int[] se, Map<String, Double> varHash) {
            if(stream>=0) strm=stream;
			return sink.getSource(source).getElement(elem+offset, strm).getParam(index);
		}
		@Override
        public int[] getSafeElementRange(DataSink sink, int strm) {
            if(stream>=0) strm=stream;
			int[] ret={-offset,sink.getSource(source).getNumElements(strm)-offset};
			return ret;
		}
		@Override
        public boolean equals(Object o) {
			if(!(o instanceof ParamNode)) return false;
			ParamNode node=(ParamNode)o;
			return source==node.source && offset==node.offset && index==node.index;
		}
        @Override
        public void collectVars(Set<String> vars) {}
        @Override
        public void inputsUsed(boolean[] inputs) { inputs[source]=true; }
        @Override
        public boolean isNumber() { return false; }
        @Override
        public EquNode simplify() {
            return this;
        }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            if(ns.containsKey(source)) {
                source=ns.get(source);
            }
        }
        @Override
        public String toString() {
            String first="";
            if(source>0 && stream==-1) first="d["+source+"].";
            else if(source>0 || stream>=0) first="d["+source+"]["+stream+"].";
            String second;
            if(offset!=0) second="p["+offset+"]["+index+"]";
            else second="p["+index+"]";
            return first+second;
        }
		private int source;
        private int stream;
		private int offset;
		private int index;
        private static final long serialVersionUID=9134689734l;
	}
    
    private static class ConstValueNode implements EquNode {
        public ConstValueNode(int src,int strm,int off,int i) { source=src; stream=strm; offset=off; index=i; }
        @Override
        public double eval(DataSink sink,int strm,int elem, int[] se, Map<String, Double> varHash) {
            if(stream>=0) strm=stream;
            return sink.getSource(source).getElement(offset, 0).getValue(index);
        }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] ret={0,Integer.MAX_VALUE};
            return ret;
        }
        @Override
        public boolean equals(Object o) {
            if(!(o instanceof ConstValueNode)) return false;
            ConstValueNode node=(ConstValueNode)o;
            return source==node.source && offset==node.offset && index==node.index;
        }
        @Override
        public void collectVars(Set<String> vars) {}
        @Override
        public void inputsUsed(boolean[] inputs) { inputs[source]=true; }
        @Override
        public boolean isNumber() { return false; }
        @Override
        public EquNode simplify() {
            return this;
        }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            if(ns.containsKey(source)) {
                source=ns.get(source);
            }
        }
        @Override
        public String toString() {
            String first="c["+source+"].";
            if(stream>=0) first="c["+source+"]["+stream+"].";
            String second;
            if(offset!=0) second="v["+offset+"]["+index+"]";
            else second="v["+index+"]";
            return first+second;
        }
        private int source;
        private int stream;
        private int offset;
        private int index;
        private static final long serialVersionUID=29837466367l;
    }
    
    private static class ConstParamNode implements EquNode {
        public ConstParamNode(int src,int strm,int off,int i) { source=src; stream=strm; offset=off; index=i; }
        @Override
        public double eval(DataSink sink,int strm,int elem, int[] se, Map<String, Double> varHash) {
            if(stream>=0) strm=stream;
            return sink.getSource(source).getElement(offset, 0).getParam(index);
        }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] ret={0,Integer.MAX_VALUE};
            return ret;
        }
        @Override
        public boolean equals(Object o) {
            if(!(o instanceof ConstParamNode)) return false;
            ConstParamNode node=(ConstParamNode)o;
            return source==node.source && offset==node.offset && index==node.index;
        }
        @Override
        public void collectVars(Set<String> vars) {}
        @Override
        public void inputsUsed(boolean[] inputs) { inputs[source]=true; }
        @Override
        public boolean isNumber() { return false; }
        @Override
        public EquNode simplify() {
            return this;
        }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            if(ns.containsKey(source)) {
                source=ns.get(source);
            }
        }
        @Override
        public String toString() {
            String first="c["+source+"].";
            if(stream>=0) first="c["+source+"]["+stream+"].";
            String second;
            if(offset!=0) second="p["+offset+"]["+index+"]";
            else second="p["+index+"]";
            return first+second;
        }
        private int source;
        private int stream;
        private int offset;
        private int index;
        private static final long serialVersionUID=25747460987l;
    }
    
    private static class SpecialValueNode implements EquNode {
        public SpecialValueNode(int src,int strm,int off,int i,int sn) {
            source=src; stream=strm; offset=off; index=i; specNum=sn;
        }
		@Override
        public double eval(DataSink sink,int strm,int elem, int[] se, Map<String, Double> varHash) {
            if(stream>=0) strm=stream;
			return sink.getSource(source).getElement(se[specNum]+offset, 0).getValue(index);
		}
        @Override
        public int[] getSafeElementRange(DataSink sink, int strm) {
            if(stream>=0) strm=stream;
            int[] ret={-offset,sink.getSource(source).getNumElements(strm)-offset};
            return ret;
        }
		@Override
        public boolean equals(Object o) {
			if(!(o instanceof ValueNode)) return false;
			ValueNode node=(ValueNode)o;
			return source==node.source && offset==node.offset && index==node.index;
		}
        @Override
        public void collectVars(Set<String> vars) {}
        @Override
        public void inputsUsed(boolean[] inputs) { inputs[source]=true; }
        @Override
        public boolean isNumber() { return false; }
        @Override
        public EquNode simplify() {
            return this;
        }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            if(ns.containsKey(source)) {
                source=ns.get(source);
            }
        }
        @Override
        public String toString() {
            String primes="'";
            for(int i=0; i<specNum; ++i) {
                primes+="'";
            }
            String first="";
            if(source>0 && stream==-1) first="d["+source+"].";
            else if(source>0 || stream>=0) first="d["+source+"]["+stream+"].";
            String second;
            if(offset!=0) second="v"+primes+"["+offset+"]["+index+"]";
            else second="v"+primes+"["+index+"]";
            return first+second;
        }
        private int source;
        private int stream;
        private int offset;
        private int index;
        private int specNum;
        private static final long serialVersionUID=6324098734612l;
    }
    
    private static class SpecialParamNode implements EquNode {
        public SpecialParamNode(int src,int strm,int off,int i,int sn) {
            source=src; stream=strm; offset=off; index=i; specNum=sn;
        }
		@Override
        public double eval(DataSink sink,int strm,int elem, int[] se, Map<String, Double> varHash) {
            if(stream>=0) strm=stream;
			return sink.getSource(source).getElement(se[specNum]+offset, 0).getParam(index);
		}
        @Override
        public int[] getSafeElementRange(DataSink sink, int strm) {
            if(stream>=0) strm=stream;
            int[] ret={-offset,sink.getSource(source).getNumElements(strm)-offset};
            return ret;
        }
		@Override
        public boolean equals(Object o) {
			if(!(o instanceof ParamNode)) return false;
			ParamNode node=(ParamNode)o;
			return source==node.source && offset==node.offset && index==node.index;
		}
        @Override
        public void collectVars(Set<String> vars) {}
        @Override
        public void inputsUsed(boolean[] inputs) { inputs[source]=true; }
        @Override
        public boolean isNumber() { return false; }
        @Override
        public EquNode simplify() {
            return this;
        }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            if(ns.containsKey(source)) {
                source=ns.get(source);
            }
        }
        @Override
        public String toString() {
            String primes="'";
            for(int i=0; i<specNum; ++i) {
                primes+="'";
            }
            String first="";
            if(source>0 && stream==-1) first="d["+source+"].";
            else if(source>0 || stream>=0) first="d["+source+"]["+stream+"].";
            String second;
            if(offset!=0) second="p"+primes+"["+offset+"]["+index+"]";
            else second="p"+primes+"["+index+"]";
            return first+second;
        }
        private int source;
        private int stream;
        private int offset;
        private int index;
        private int specNum;
        private static final long serialVersionUID=56014019841416l;
    }
    
    private static class NumberNode implements EquNode {
        public NumberNode(double v) { val=v; }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return val; }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] ret={0,Integer.MAX_VALUE};
            return ret;
        }
		@Override
        public boolean equals(Object o) {
			if(!(o instanceof NumberNode)) return false;
			NumberNode node=(NumberNode)o;
			return val==node.val;
		}
        @Override
        public void collectVars(Set<String> vars) {}
        @Override
        public void inputsUsed(boolean[] inputs) {}
        @Override
        public boolean isNumber() { return true; }
        @Override
        public EquNode simplify() { return this; }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {}
        @Override
        public String toString() { return Double.toString(val); }
        private double val;
        private static final long serialVersionUID=145986436l;
    }

    private static class VariableNode implements EquNode {
        public VariableNode(String n) { name=n; }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return varHash.get(name); }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] ret={0,Integer.MAX_VALUE};
            return ret;
        }
        @Override
        public boolean equals(Object o) {
            if(!(o instanceof VariableNode)) return false;
            VariableNode node=(VariableNode)o;
            return name.equals(node.name);
        }
        @Override
        public void collectVars(Set<String> vars) { vars.add(name); }
        @Override
        public void inputsUsed(boolean[] inputs) {}
        @Override
        public boolean isNumber() { return false; }
        @Override
        public EquNode simplify() { return this; }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {}
        @Override
        public String toString() { return name; }
        private String name;
        private static final long serialVersionUID=45357347436l;
    }

    private static class SignNode extends MonaryOpt {
        public SignNode(EquNode a) { super(a); }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.signum(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "sign("+arg+")"; }
        private static final long serialVersionUID=867483698095l;
    }

    private static class SinNode extends MonaryOpt {
        public SinNode(EquNode a) { super(a); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.sin(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "sin("+arg+")"; }
        private static final long serialVersionUID=14986498095l;
    }

    private static class CosNode extends MonaryOpt {
        public CosNode(EquNode a) { super(a); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.cos(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "cos("+arg+")"; }
        private static final long serialVersionUID=34568907346l;
    }

    private static class SinhNode extends MonaryOpt {
        public SinhNode(EquNode a) { super(a); }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.sinh(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "sinh("+arg+")"; }
        private static final long serialVersionUID=14986498095l;
    }

    private static class CoshNode extends MonaryOpt {
        public CoshNode(EquNode a) { super(a); }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.cosh(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "cosh("+arg+")"; }
        private static final long serialVersionUID=34568907346l;
    }

    private static class TanNode extends MonaryOpt {
        public TanNode(EquNode a) { super(a); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.tan(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "tan("+arg+")"; }
        private static final long serialVersionUID=147560743426l;
    }

    private static class SqrtNode extends MonaryOpt {
        public SqrtNode(EquNode a) { super(a); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.sqrt(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "sqrt("+arg+")"; }
        private static final long serialVersionUID=1234690871467l;
    }

    private static class CbrtNode extends MonaryOpt {
        public CbrtNode(EquNode a) { super(a); }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.cbrt(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "cbrt("+arg+")"; }
        private static final long serialVersionUID=1234690871467l;
    }

    private static class ExpNode extends MonaryOpt {
        public ExpNode(EquNode a) { super(a); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.exp(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "exp("+arg+")"; }
        private static final long serialVersionUID=32508714614l;
    }

    private static class LogNode extends MonaryOpt {
        public LogNode(EquNode a) { super(a); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.log(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "log("+arg+")"; }
        private static final long serialVersionUID=879142361357l;
    }

    private static class Log10Node extends MonaryOpt {
        public Log10Node(EquNode a) { super(a); }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.log10(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "log10("+arg+")"; }
        private static final long serialVersionUID=879174572345l;
    }

    private static class Log2Node extends MonaryOpt {
        public Log2Node(EquNode a) { super(a); }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.log(arg.eval(sink,stream,elem,se, varHash))/Math.log(2.0); }
        @Override
        public String toString() { return "log2("+arg+")"; }
        private static final long serialVersionUID=879174572345l;
    }

    private static class AbsNode extends MonaryOpt {
        public AbsNode(EquNode a) { super(a); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.abs(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "abs("+arg+")"; }
        private static final long serialVersionUID=4134897143096l;
    }

    private static class RandNode extends MonaryOpt {
        public RandNode(EquNode a) { super(a); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.random()*arg.eval(sink,stream,elem,se, varHash); }
        @Override
        public String toString() { return "rand("+arg+")"; }
        @Override
        public boolean isNumber() { return false; }
        private static final long serialVersionUID=2359807236l;
    }

    private static class FloorNode extends MonaryOpt {
        public FloorNode(EquNode a) { super(a); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.floor(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "floor("+arg+")"; }
        private static final long serialVersionUID=23469870572l;
    }

    private static class RoundNode extends MonaryOpt {
        public RoundNode(EquNode a) { super(a); }
		@Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.round(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "round("+arg+")"; }
        private static final long serialVersionUID=5367347801l;
    }

    private static class IndexNode implements EquNode {
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return elem; }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            return new int[]{0,Integer.MAX_VALUE};
        }
        @Override
        public boolean equals(Object o) {
            if(!(o instanceof IndexNode)) return false;
            return true;
        }
        @Override
        public void collectVars(Set<String> vars) {}
        @Override
        public void inputsUsed(boolean[] inputs) {}
        @Override
        public boolean isNumber() { return false; }
        @Override
        public EquNode simplify() { return this; }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {}
        @Override
        public String toString() { return "index"; }
        private static final long serialVersionUID=83482323768348l;
    }

    private static class NumElementsNode implements EquNode {
        public NumElementsNode(String args) {
            if(args!=null && args.length()>2 && args.charAt(0)=='(') {
                int commaIndex=args.indexOf(",");
                if(commaIndex<0) {
                    source=Integer.parseInt(args.substring(1,args.length()-1));
                } else {
                    source=Integer.parseInt(args.substring(1,commaIndex));
                    stream=Integer.parseInt(args.substring(commaIndex+1,args.length()-1));                    
                }
            }
        }
        @Override
        public double eval(DataSink sink,int strm,int elem, int[] se, Map<String, Double> varHash) {
            if(stream>=0) strm=stream;
            return sink.getSource(source).getNumElements(strm);
        }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            return new int[]{0,Integer.MAX_VALUE};
        }
        @Override
        public boolean equals(Object o) {
            if(!(o instanceof NumElementsNode)) return false;
            return true;
        }
        @Override
        public void collectVars(Set<String> vars) {}
        @Override
        public void inputsUsed(boolean[] inputs) {inputs[source]=true;}
        @Override
        public boolean isNumber() { return false; }
        @Override
        public EquNode simplify() { return this; }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            if(ns.containsKey(source)) {
                source=ns.get(source);
            }
        }
        @Override
        public String toString() {
            if(stream==-1) return "numElements("+source+")";
            return "numElements("+source+","+stream+")";
        }
        private int source;
        private int stream=-1;
        private static final long serialVersionUID=54743734878658l;
    }

    private static class NumValuesNode implements EquNode {
        public NumValuesNode(String args) {
            if(args!=null && args.length()>2 && args.charAt(0)=='(') {
                int commaIndex=args.indexOf(",");
                if(commaIndex<0) {
                    source=Integer.parseInt(args.substring(1,args.length()-1));
                } else {
                    source=Integer.parseInt(args.substring(1,commaIndex));
                    stream=Integer.parseInt(args.substring(commaIndex+1,args.length()-1));                    
                }
            }
        }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return sink.getSource(source).getElement(elem, 0).getNumValues(); }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] ret={0,sink.getSource(source).getNumElements(0)};
            return ret;
        }
        @Override
        public boolean equals(Object o) {
            if(!(o instanceof NumValuesNode)) return false;
            return true;
        }
        @Override
        public void collectVars(Set<String> vars) {}
        @Override
        public void inputsUsed(boolean[] inputs) {inputs[source]=true;}
        @Override
        public boolean isNumber() { return false; }
        @Override
        public EquNode simplify() { return this; }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            if(ns.containsKey(source)) {
                source=ns.get(source);
            }
        }
        @Override
        public String toString() {
            if(stream==-1) return "numValues("+source+")";
            return "numValues("+source+","+stream+")";
        }
        private int source;
        private int stream=-1;
        private static final long serialVersionUID=5474356378658l;
    }

    private static class NumParamsNode implements EquNode {
        public NumParamsNode(String args) {
            if(args!=null && args.length()>2 && args.charAt(0)=='(') {
                int commaIndex=args.indexOf(",");
                if(commaIndex<0) {
                    source=Integer.parseInt(args.substring(1,args.length()-1));
                } else {
                    source=Integer.parseInt(args.substring(1,commaIndex));
                    stream=Integer.parseInt(args.substring(commaIndex+1,args.length()-1));                    
                }
            }
        }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return sink.getSource(source).getElement(elem, 0).getNumParams(); }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] ret={0,sink.getSource(source).getNumElements(0)};
            return ret;
        }
        @Override
        public boolean equals(Object o) {
            if(!(o instanceof NumParamsNode)) return false;
            return true;
        }
        @Override
        public void collectVars(Set<String> vars) {}
        @Override
        public void inputsUsed(boolean[] inputs) {inputs[source]=true;}
        @Override
        public boolean isNumber() { return false; }
        @Override
        public EquNode simplify() { return this; }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            if(ns.containsKey(source)) {
                source=ns.get(source);
            }
        }
        @Override
        public String toString() {
            if(stream==-1) return "numParams("+source+")";
            return "numParams("+source+","+stream+")";
        }
        private int source;
        private int stream;
        private static final long serialVersionUID=96474356378658l;
    }

    private static class SchemeNode implements EquNode {
        public SchemeNode(String c) {
            codeString=c;
        }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) {
            if(code==null) code=SchemeConsole.parse(codeString,SVSchemeUtil.defaultGlobalEnvironment());
            return ((SchemeValue)code.eval(SVSchemeUtil.formulaEnvironment(sink,elem,se))).numericValue();
        }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            return new int[]{0,Integer.MAX_VALUE};
        }
        @Override
        public boolean equals(Object o) {
            if(!(o instanceof SchemeNode)) return false;
            return code.equals(((SchemeNode)o).code);
        }
        @Override
        public void collectVars(Set<String> vars) {}
        @Override
        public void inputsUsed(boolean[] inputs) {}
        @Override
        public boolean isNumber() { return false; }
        @Override
        public EquNode simplify() { return this; }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {}
        @Override
        public String toString() { return "scm("+codeString+")"; }

        private String codeString;
        private transient SchemeElement code;

        private static final long serialVersionUID=8234690872346l;
    }
    
    private static class Atan2Node extends BinaryOpt {
        public Atan2Node(EquNode arg1,EquNode arg2) { super(arg1,arg2); }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.atan2(left.eval(sink,stream,elem,se, varHash),right.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "atan2("+left+","+right+")"; }
        private static final long serialVersionUID=783923672235l;
    }    

    private static class HypotNode extends BinaryOpt {
        public HypotNode(EquNode arg1,EquNode arg2) { super(arg1,arg2); }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.hypot(left.eval(sink,stream,elem,se, varHash),right.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "hypot("+left+","+right+")"; }
        private static final long serialVersionUID=783923672235l;
    }    

    private static class MinNode extends BinaryOpt {
        public MinNode(EquNode arg1,EquNode arg2) { super(arg1,arg2); }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.min(left.eval(sink,stream,elem,se,varHash),right.eval(sink,stream,elem,se,varHash)); }
        @Override
        public String toString() { return "min("+left+","+right+")"; }
        private static final long serialVersionUID=78392372357l;
    }    

    private static class MaxNode extends BinaryOpt {
        public MaxNode(EquNode arg1,EquNode arg2) { super(arg1,arg2); }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.max(left.eval(sink,stream,elem,se, varHash),right.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "max("+left+","+right+")"; }
        private static final long serialVersionUID=57987355672235l;
    }    

    private static class AsinNode extends MonaryOpt {
        public AsinNode(EquNode a) { super(a); }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.asin(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "asin("+arg+")"; }
        private static final long serialVersionUID=14986498095l;
    }

    private static class AcosNode extends MonaryOpt {
        public AcosNode(EquNode a) { super(a); }
        @Override
        public double eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return Math.acos(arg.eval(sink,stream,elem,se, varHash)); }
        @Override
        public String toString() { return "acos("+arg+")"; }
        private static final long serialVersionUID=34568907346l;
    }

    /**
     * This inner class is intended to represent grouping information for a formula.  This
     * allows special values from a group to be more ubiquitously used throughout SwiftVis.
     * The syntax for this information is {group formula, select0, select1, ...}.
     * The comma delimited list is boolean expressions or expressions of the form min ...
     * or max ... where ... is a data formula.  If it is a boolean values, the first
     * element in the group that causes the expression to be true will be the one that is
     * used for the special value with that index.  If it is min or max the elements that
     * returns the minimum or maximum value for the given data formula will be the special
     * index.  If there is a tie for min or max, the first one found will be used.
     * 
     * For example, if the input were coming from a binary position file in SWIFT, you could
     * use the group information {v[0],p[0]=-2} to make it so that v'[3] would be the
     * inclination of the second planet.
     * 
     * Note that there are odd behaviors that result from using a constant for the group
     * formula or with any input where all the elements have the same value for the group
     * formula.  Because the group selection is cached for efficiency, it will not be
     * reprocessed even for another pass through the data if the value is unchanged from
     * one pass through the data to another.
     * 
     * @author Mark Lewis
     */
    public static class GroupInformation implements Serializable {
        public GroupInformation(GroupInformation c) {
            groupFormula=c.groupFormula;
            selector=c.selector;
            groupStart=-1;
            groupEnd=-1;
        }
        public GroupInformation(String form) {
            if(form.charAt(0)=='{') form=form.substring(1,form.length()-1);
            form=form.trim();
            int braceCount=0;
            int index=-1;
            for(int i=0; i<form.length(); ++i) {
                switch(form.charAt(i)) {
                	case '{':
                	    braceCount++;
                	    break;
                	case '}':
                	    braceCount--;
                	    break;
                	case ',':
                	    if(braceCount==0) index++;
                	    break;
                }
            }
            selector=new SelectorType[index+1];
            index=-1;
            int beginLoc=1;
            braceCount=0;
            for(int i=0; i<form.length(); ++i) {
                switch(form.charAt(i)) {
                	case '{':
                	    braceCount++;
                	    break;
                	case '}':
                	    braceCount--;
                	    break;
                	case ',':
                	    if(braceCount==0) {
	                	    if(index==-1) {
	                	        groupFormula=new DataFormula(form.substring(0,i));
	                	    } else {
                                String ss=form.substring(beginLoc,i).trim();
                                if(ss.startsWith("min")) {
                                    selector[index]=new MinSelectorType(new DataFormula(ss.substring(3)));
                                } else if(ss.startsWith("max")) {
                                    selector[index]=new MaxSelectorType(new DataFormula(ss.substring(3)));
                                } else {
                                    selector[index]=new BooleanSelectorType(new BooleanFormula(ss));
                                }
	                	    }
	                	    beginLoc=i+1;
	                	    index++;
                	    }
                	    break;
                }
            }
            String ss=form.substring(beginLoc).trim();
            if(ss.startsWith("min")) {
                selector[index]=new MinSelectorType(new DataFormula(ss.substring(3)));
            } else if(ss.startsWith("max")) {
                selector[index]=new MaxSelectorType(new DataFormula(ss.substring(3)));
            } else {
                selector[index]=new BooleanSelectorType(new BooleanFormula(ss));
            }
            groupStart=-1;
            groupEnd=-1;
        }
        public int[] getSpecialArray(DataSink sink,int stream,int elem, int[] specialElem) {
            if(elem<groupStart || elem>groupEnd) {
                lastSelection=new int[selector.length];
                double groupVal=groupFormula.valueOf(sink,stream,elem, specialElem);
                groupStart=elem-1;
                int[] range=groupFormula.getSafeElementRange(sink, 0);
                for(int j=0; j<selector.length; ++j) {
                    int[] tmp=selector[j].getSafeElementRange(sink);
                    if(tmp[0]>range[0]) range[0]=tmp[0];
                    if(tmp[1]<range[1]) range[1]=tmp[1];
                }
                while(groupStart>=range[0] && groupFormula.valueOf(sink,stream,groupStart, specialElem)==groupVal)
                    groupStart--;
                groupStart++;
                groupEnd=elem+1;
                while(groupEnd<range[1] && groupFormula.valueOf(sink,stream,groupEnd, specialElem)==groupVal)
                    groupEnd++;
                groupEnd--;
                for(int j=0; j<selector.length; ++j) {
                    lastSelection[j]=selector[j].findSelection(groupStart,groupEnd,sink,specialElem);
                }
            }
            int[] ret=new int[selector.length];
            for(int i=0; i<ret.length; ++i) {
                ret[i]=lastSelection[i];
            }
            return ret;
        }
        @Override
        public boolean equals(Object o) {
            if(o==null || !(o instanceof GroupInformation)) return false;
            GroupInformation gi=(GroupInformation)o;
            boolean selectorsEqual=true;
            if(selector.length!=gi.selector.length) return false;
            for(int i=0; i<selector.length && selectorsEqual; ++i) {
                if(!selector[i].equals(gi.selector[i])) selectorsEqual=false;
            }
            return selectorsEqual && groupFormula.equals(gi.groupFormula); 
        }
        public void reset() {
            groupStart=-1;
            groupEnd=-1;
        }

        private DataFormula groupFormula;
        private SelectorType[] selector;
        private int groupStart=-1;
        private int groupEnd=-1;
        private int[] lastSelection;
        private static final long serialVersionUID=146980756238l;
    }
    
    private static interface SelectorType extends Serializable {
        int findSelection(int groupStart,int groupEnd,DataSink sink,int[] specialElem);
        int[] getSafeElementRange(DataSink sink);
    }
    
    private static class BooleanSelectorType implements SelectorType {
        public BooleanSelectorType(BooleanFormula bf) {
            selector=bf;
        }
        @Override
        public int findSelection(int groupStart,int groupEnd,DataSink sink,int[] specialElem) {
            for(int i=groupStart; i<=groupEnd; ++i) {
                if(selector.valueOf(sink,0,i, specialElem)) {
                    return i;
                }
            }
            return groupStart;
        }
        @Override
        public int[] getSafeElementRange(DataSink sink) {
            return selector.getSafeElementRange(sink, 0);
        }
        private final BooleanFormula selector;
        private static final long serialVersionUID = 5150645163567185087L;
    }
    private static class MinSelectorType implements SelectorType {
        public MinSelectorType(DataFormula df) {
            selector=df;
        }
        @Override
        public int findSelection(int groupStart,int groupEnd,DataSink sink,int[] specialElem) {
            int ret=groupStart;
            double minVal=selector.valueOf(sink,0,ret, specialElem);
            for(int i=groupStart+1; i<=groupEnd; ++i) {
                double val=selector.valueOf(sink,0,i, specialElem);
                if(val<minVal) {
                    ret=i;
                    minVal=val;
                }
            }
            return ret;
        }
        @Override
        public int[] getSafeElementRange(DataSink sink) {
            return selector.getSafeElementRange(sink, 0);
        }
        private final DataFormula selector;
        private static final long serialVersionUID = 5125851635347435087L;
    }
    private static class MaxSelectorType implements SelectorType {
        public MaxSelectorType(DataFormula df) {
            selector=df;
        }
        @Override
        public int findSelection(int groupStart,int groupEnd,DataSink sink,int[] specialElem) {
            int ret=groupStart;
            double maxVal=selector.valueOf(sink,0,ret, specialElem);
            for(int i=groupStart+1; i<=groupEnd; ++i) {
                double val=selector.valueOf(sink,0,i, specialElem);
                if(val>maxVal) {
                    ret=i;
                    maxVal=val;
                }
            }
            return ret;
        }
        @Override
        public int[] getSafeElementRange(DataSink sink) {
            return selector.getSafeElementRange(sink, 0);
        }
        private final DataFormula selector;
        private static final long serialVersionUID = 5125851635347435087L;
    }
}


*/